import os
import asyncio
import logging
import random
import math
import re

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ReplyKeyboardRemove,
    InputMediaPhoto,
    InputMediaVideo,
    KeyboardButton,
    ReplyKeyboardMarkup,
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
    ConversationHandler,
)
from telegram.error import RetryAfter, TelegramError, BadRequest
from telegram.constants import ParseMode


# ุฅุนุฏุงุฏ ุงูุชุณุฌูู
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# ุงูุญุงูุงุช ูููุญุงุฏุซุฉ
ASKING_FOR_CAPTION = 1
ASKING_FOR_MANUAL_CAPTION = 2
CHANGING_SPLIT_MODE = 4 # ุชู ุฅุฒุงูุฉ ุงูุญุงูุฉ 3


# Callbacks prefixes
CAPTION_CB_PREFIX = "cap_"
CANCEL_CB_DATA = "cancel_op"
SPLIT_SET_CB_PREFIX = "splitset_"


# ุงูุฑุณุงุฆู ุงููุณุชุฎุฏูุฉ
MESSAGES = {
    "greeting": (
        "ูุฑุญุจุงู {username}! ูู ุณุจู ุฃู ูุฌุฏุช ุตูุฑุงู ุฑุงุฆุนุฉ ุนูู ุชูููุฌุฑุงู "
        "ูุฃุฑุฏุช ุชุฌููุนูุง ูู ุฃูุจููุ ููู ูู ุชุฑุบุจ ูู ุชูุฒูููุง ุซู ุฅุนุงุฏุฉ ุฑูุนูุงุ "
        "ุฏุนูู ุฃููู ุจุฐูู ุจุณุฑุนุฉ!\n\n"
        "ุฃุฑุณู ูู ุฃู ุตูุฑ ุฃู ููุฏูููุงุช ูุณุฃููู ุจุฅูุดุงุก ุฃูุจููุงุช ูููุง!\n\n"
    ),
    "destination_set_success": "๐ ุชู ุชุนููู ูุฐู ุงูุฏุฑุฏุดุฉ ููุฌูุฉ ุชููุงุฆูุฉ ูุฅุฑุณุงู ุงูุฃูุจููุงุช.",
    "help": (
        'ููุท ูู ุจุชุญููู ุฃู ุฅุฑุณุงู ุตูุฑ ูููุฏูููุงุช ูุชุนุฏุฏุฉ. ุนูุฏูุง ุชูุชููุ ุงุถุบุท ุนูู ุฒุฑ "ุฅูุดุงุก ุฃูุจูู" '
        'ูุณุชุญุตู ุนูู ุฌููุน ูููุงุชู ุงูุชู ุฃุฑุณูุชูุง ูุณุจูุงู ูุฌูุนุฉ ูุฃูุจููุงุช. ุฅุฐุง ุฃุฎุทุฃุชุ ุงููุฑ ุนูู "ุฅุนุงุฏุฉ ุชุนููู ุงูุฃูุจูู" ููุจุฏุก ูู ุฌุฏูุฏ.\n\n'
        "ูุฐุง ุงูุนูู ุชู ุจูุงุณุทุฉ @wjclub."
    ),
    "settings": "ูุง ุชูุฌุฏ ุฅุนุฏุงุฏุงุช ูุชุบููุฑูุง ููุง.",
    "source": "https://github.com/wjclub/telegram-bot-album-creator",
    "keyboard_done": "ุฅูุดุงุก ุฃูุจูู",
    "keyboard_clear": "ุฅุนุงุฏุฉ ุชุนููู ุงูุฃูุจูู",
    "keyboard_change_split_mode": "ุชุบููุฑ ููุท ุงูุชูุณูู ๐",
    "not_enough_media_items": "๐ฆ ุชุญุชุงุฌ ุฅูู ุฅุฑุณุงู ุตูุฑุชูู ุฃู ุฃูุซุฑ ูุชูููู ุฃูุจูู.",
    "queue_cleared": "ููุฏ ูุณูุช ูู ุงูุตูุฑ ูุงูููุฏูููุงุช ุงูุชู ุฃุฑุณูุชูุง ูู. ูุฏูู ูุฑุตุฉ ุฌุฏูุฏุฉ.",
    "album_caption_prompt": "ุงูุฑุฌุงุก ุงุฎุชูุงุฑ ุชุนููู ููุฃูุจูู ูู ุงูุฃุฒุฑุงุฑ ุฃุฏูุงู:",
    "album_caption_manual_prompt": "ุงูุฑุฌุงุก ุฅุฏุฎุงู ุงูุชุนููู ุงูุฐู ุชุฑูุฏู ููุฃูุจูู. (ุณูููู ูุฐุง ูู ุงูุชุนููู ููุท ูุฃูู ูุณุงุฆุท ูู ูู ุฃูุจูู ุฅุฐุง ูุงู ููุงู ุฃูุจููุงุช ูุชุนุฏุฏุฉ).\n\nุฅุฐุง ููุช ูุง ุชุฑูุฏ ุฃู ุชุนูููุ ููุท ุฃุฑุณู ูู ููุทุฉ `.`",
    "album_caption_confirm": "๐ ุญุณูุงู! ุงูุชุนููู ุงูุฐู ุงุฎุชุฑุชู ูู: `{caption}`.\n",
    "album_caption_confirm_no_caption": "๐ ุญุณูุงู! ูู ูููู ููุงู ุชุนููู ููุฃูุจูู.\n",
    "processing_album_start": "โณ ุฌุงุฑู ุฅูุดุงุก ุงูุฃูุจูู. ูุฏ ูุณุชุบุฑู ูุฐุง ุจุนุถ ุงูููุช...",
    "progress_update": "ุฌุงุฑู ุฅุฑุณุงู ุงูุฃูุจูู: *{processed_albums}/{total_albums}*\nุงูููุช ุงููุชุจูู ุงูููุฏุฑ: *{time_remaining_str}*",
    "cancel_caption": "ููุฏ ุฃูุบูุช ุนูููุฉ ุฅูุดุงุก ุงูุฃูุจูู. ููููู ุงูุจุฏุก ูู ุฌุฏูุฏ.",
    "cancel_operation": "ุชู ุฅูุบุงุก ุงูุนูููุฉ.",
    "album_comment_option_manual": "ุฅุฏุฎุงู ุชุนููู ูุฏูู",
    "invalid_input_choice": "ุฎูุงุฑ ุบูุฑ ุตุงูุญ ุฃู ุฅุฏุฎุงู ุบูุฑ ูุชููุน. ุงูุฑุฌุงุก ุงูุงุฎุชูุงุฑ ูู ุงูุฃุฒุฑุงุฑ ุฃู ุฅูุบุงุก ุงูุนูููุฉ.",
    "success_message_permanent_prompt": "ููููู ุงูุขู ุฅุฑุณุงู ุงููุฒูุฏ ูู ุงููุณุงุฆุท ุฃู ุงุณุชุฎุฏุงู ุงูุฃุฒุฑุงุฑ ุฃุฏูุงู.",
    "ask_split_mode_setting": "ุงุฎุชุฑ ููุท ุชูุณูู ุงูุฃูุจูู ุงูุงูุชุฑุงุถู. ุณูุชู ุงุณุชุฎุฏุงูู ููู ุงูุฃูุจููุงุช ุงููุงุฏูุฉ ุญุชู ุชุบููุฑู ูุฑุฉ ุฃุฎุฑู.",
    "split_mode_set_success": "๐ ุชู ุชุนููู ููุท ุชูุณูู ุงูุฃูุจููุงุช ุฅูู: *{split_mode_name}*.",
    "album_split_mode_full": "ุฃูุจููุงุช ูุงููุฉ (10 ุนูุงุตุฑ)",
    "album_split_mode_equal": "ุชูุณูู ูุชุณุงูู",
}

# ุงูุชุนูููุงุช ุงูุฌุงูุฒุฉ
PREDEFINED_CAPTION_OPTIONS = [
    "ุนุฑุถ ูุฑุนุงู ุงุฌุงูุจ ๐๐", "๐ ๐ฅ .", "ุญุตุฑูุงุช ูููุน๐๐ฅ.", "ุญุตุฑูุงุช๐",
    "ุนุฑุจู ูููุน๐๐ฅ.", "ุงุฌูุจู ูููุน๐๐ฅ.", "ุนุฑุจู ๐๐ฅ.", "ุงุฌูุจู ๐๐ฅ.",
    "ูููุนุงุช ๐๐ฅ.", "ุญุตุฑูุงุช ุนุฑุจู ๐๐ฅ.", "ุญุตุฑูุงุช ุงุฌูุจู ๐๐ฅ.",
    "ูุง ููุฌุฏ ุชุนููู", MESSAGES["album_comment_option_manual"],
]

# ุฏุงูุฉ ุงูุชุฃุฎูุฑ ุงูุนุดูุงุฆู
prev_delay = None
def get_random_delay(min_delay=5, max_delay=30, min_diff=7):
    global prev_delay
    delay = random.randint(min_delay, max_delay)
    while prev_delay is not None and abs(delay - prev_delay) < min_diff:
        delay = random.randint(min_delay, max_delay)
    prev_delay = delay
    return delay

# ุชููุฆุฉ ุจูุงูุงุช ุงููุณุชุฎุฏู
async def initialize_user_data(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    """ูุถูู ุชููุฆุฉ context.user_data ุจุงููุงูู ูุชุนููู ูุฌูุฉ ุงูุฅุฑุณุงู."""
    defaults = {
        "media_queue": [],
        "messages_to_delete": [],
        "temp_messages_to_clean": [],
        "progress_message_id": None,
        "album_split_mode": "equal", # "equal" ุฃู "full_10"
        "album_split_mode_name": MESSAGES["album_split_mode_equal"]
    }
    for key, value in defaults.items():
        if key not in context.user_data:
            context.user_data[key] = value if not isinstance(value, list) else list(value)
    
    # ุชุนููู ูุฌูุฉ ุงูุฅุฑุณุงู ุชููุงุฆููุง ุฅูู ุงูุฏุฑุฏุดุฉ ุงูุญุงููุฉ ุฏุงุฆููุง
    context.user_data["album_destination_chat_id"] = chat_id
    context.user_data["album_destination_name"] = "ูุฐู ุงููุญุงุฏุซุฉ"

# ุฏุงูุฉ ุจูุงุก ููุญุฉ ุงูููุงุชูุญ ุงูุฑุฆูุณูุฉ
def get_main_reply_markup() -> ReplyKeyboardMarkup:
    # ุชู ุฅุฒุงูุฉ ุฒุฑ ุชุบููุฑ ุงููุฌูุฉ
    reply_keyboard = [
        [KeyboardButton(MESSAGES["keyboard_done"]), KeyboardButton(MESSAGES["keyboard_clear"])],
        [KeyboardButton(MESSAGES["keyboard_change_split_mode"])]
    ]
    return ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=False)


async def delete_messages_from_queue(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> None:
    message_ids = list(context.user_data.get("messages_to_delete", []))
    for msg_id in message_ids:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
        except BadRequest: # Message already deleted
            pass
        except Exception as e:
            logger.warning(f"Could not delete message {msg_id} in chat {chat_id}: {e}")
    context.user_data["messages_to_delete"].clear()

# ุงูุฃูุงูุฑ ุงูุฃุณุงุณูุฉ
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.effective_chat.id
    await initialize_user_data(context, chat_id)
    
    username = update.effective_user.username or "human"
    message = MESSAGES["greeting"].format(username=username)
    await update.message.reply_text(message, reply_markup=get_main_reply_markup())
    
    # ุฅุฑุณุงู ุฑุณุงูุฉ ุชุฃููุฏ ุจุฃู ุงููุฌูุฉ ุชู ุชุญุฏูุฏูุง ุชููุงุฆููุง
    await update.message.reply_text(MESSAGES["destination_set_success"])

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(MESSAGES["help"])

# ุฅุถุงูุฉ ุงููุณุงุฆุท
async def add_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await initialize_user_data(context, update.effective_chat.id)
    context.user_data["media_queue"].append({"type": "photo", "media": update.message.photo[-1].file_id})
    logger.info("Added photo")

async def add_video(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await initialize_user_data(context, update.effective_chat.id)
    context.user_data["media_queue"].append({"type": "video", "media": update.message.video.file_id})
    logger.info("Added video")

# -------------------------------------------------------------
# ุฏูุงู ConversationHandler (ูุชุบููุฑ ููุท ุงูุชูุณูู)
# -------------------------------------------------------------
async def prompt_for_split_mode_setting(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ุชุทูุจ ูู ุงููุณุชุฎุฏู ุงุฎุชูุงุฑ ุฅุนุฏุงุฏ ุงูุชูุณูู ุงูุฏุงุฆู."""
    keyboard = [
        [InlineKeyboardButton(MESSAGES["album_split_mode_full"], callback_data=f"{SPLIT_SET_CB_PREFIX}full_10")],
        [InlineKeyboardButton(MESSAGES["album_split_mode_equal"], callback_data=f"{SPLIT_SET_CB_PREFIX}equal")],
        [InlineKeyboardButton("โ ุฅูุบุงุก", callback_data=CANCEL_CB_DATA)]
    ]
    prompt_msg = await update.message.reply_text(MESSAGES["ask_split_mode_setting"], reply_markup=InlineKeyboardMarkup(keyboard))
    context.user_data.get("messages_to_delete", []).append(prompt_msg.message_id)
    return CHANGING_SPLIT_MODE

async def handle_split_mode_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ุชุณุชูุจู ุงุฎุชูุงุฑ ุงููุณุชุฎุฏู ูุชุฎุฒูู ูุฅุนุฏุงุฏ ุฏุงุฆู."""
    query = update.callback_query
    choice = query.data
    await query.answer()
    try: await query.delete_message()
    except BadRequest: pass

    if choice == CANCEL_CB_DATA:
        await cancel_operation_general(update, context)
        return ConversationHandler.END

    mode, mode_name = (None, None)
    if choice == f"{SPLIT_SET_CB_PREFIX}full_10":
        mode, mode_name = "full_10", MESSAGES["album_split_mode_full"]
    elif choice == f"{SPLIT_SET_CB_PREFIX}equal":
        mode, mode_name = "equal", MESSAGES["album_split_mode_equal"]
    
    if mode:
        context.user_data["album_split_mode"] = mode
        context.user_data["album_split_mode_name"] = mode_name
        await context.bot.send_message(query.message.chat_id, MESSAGES["split_mode_set_success"].format(split_mode_name=mode_name), parse_mode=ParseMode.MARKDOWN)

    return ConversationHandler.END

# -------------------------------------------------------------
# ุฏูุงู ConversationHandler (ูุฅูุดุงุก ุงูุฃูุจูู)
# -------------------------------------------------------------
async def start_album_creation_process(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ุงูุฎุทูุฉ ุงูุฃููู ูุฅูุดุงุก ุงูุฃูุจูู: ุชุชุญูู ูู ูู ุดูุก ูุชุทูุจ ุงูุชุนููู ูุจุงุดุฑุฉ.
    """
    chat_id = update.effective_chat.id
    await initialize_user_data(context, chat_id)
    
    # ูู ูุนุฏ ููุงู ุญุงุฌุฉ ููุชุญูู ูู ูุฌูุฉ ุงูุฅุฑุณุงู ูุฃููุง ุชูุถุจุท ุชููุงุฆููุง
    
    if len(context.user_data["media_queue"]) < 2:
        await update.message.reply_text(MESSAGES["not_enough_media_items"])
        return ConversationHandler.END

    keyboard = []
    for i, caption in enumerate(PREDEFINED_CAPTION_OPTIONS):
        keyboard.append([InlineKeyboardButton(caption, callback_data=f"{CAPTION_CB_PREFIX}{i}")])
    keyboard.append([InlineKeyboardButton("โ ุฅูุบุงุก", callback_data=CANCEL_CB_DATA)])
    
    prompt_msg = await update.message.reply_text(MESSAGES["album_caption_prompt"], reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)
    context.user_data["messages_to_delete"].append(prompt_msg.message_id)
    
    return ASKING_FOR_CAPTION

async def handle_caption_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    choice = query.data
    await query.answer()
    try: await query.delete_message()
    except BadRequest: pass

    if choice == CANCEL_CB_DATA:
        await cancel_album_creation(update, context)
        return ConversationHandler.END
    
    caption_index = int(choice.replace(CAPTION_CB_PREFIX, ""))
    selected_option = PREDEFINED_CAPTION_OPTIONS[caption_index]

    if selected_option == MESSAGES["album_comment_option_manual"]:
        prompt_msg = await context.bot.send_message(query.message.chat_id, MESSAGES["album_caption_manual_prompt"], reply_markup=ReplyKeyboardRemove(), parse_mode=ParseMode.MARKDOWN)
        context.user_data["messages_to_delete"].append(prompt_msg.message_id)
        return ASKING_FOR_MANUAL_CAPTION
    
    user_caption = "" if selected_option == "ูุง ููุฌุฏ ุชุนููู" else selected_option
    context.user_data["current_album_caption"] = user_caption
    return await finalize_album_action(update, context)

async def receive_manual_album_caption(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_caption = update.message.text
    context.user_data["current_album_caption"] = "" if user_caption == '.' else user_caption
    return await finalize_album_action(update, context)

async def finalize_album_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    chat_id = update.effective_chat.id
    await delete_messages_from_queue(context, chat_id)

    progress_msg = await context.bot.send_message(
        chat_id=chat_id,
        text=MESSAGES["processing_album_start"],
        parse_mode=ParseMode.MARKDOWN,
    )
    context.user_data["progress_message_id"] = progress_msg.message_id

    await execute_album_creation(update, context)

    context.user_data.pop("current_album_caption", None)
    
    progress_msg_id = context.user_data.pop("progress_message_id", None)
    if progress_msg_id:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=progress_msg_id)
        except Exception:
            pass
    
    return ConversationHandler.END

# -------------------------------------------------------------
# ุฏูุงู ุงูุชูููุฐ ูุงูุฅูุบุงุก
# -------------------------------------------------------------

async def execute_album_creation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    media_queue = context.user_data.get("media_queue", [])
    total_media = len(media_queue)
    user_chat_id = update.effective_chat.id
    target_chat_id = context.user_data["album_destination_chat_id"] # ุณูุชู ุชุนููููุง ุฏุงุฆููุง
    album_caption = context.user_data.get("current_album_caption", "")
    
    split_mode = context.user_data.get("album_split_mode", "equal")
    logger.info(f"Creating album. Media: {total_media}, Split mode: {split_mode}")

    chunks = []
    max_items_per_album = 10
    if split_mode == 'full_10':
        chunks = [media_queue[i:i + max_items_per_album] for i in range(0, total_media, max_items_per_album)]
    else: # equal split
        if total_media > 0:
            num_albums = math.ceil(total_media / max_items_per_album)
            base_size = total_media // num_albums
            rem = total_media % num_albums
            sizes = [base_size + 1 if i < rem else base_size for i in range(num_albums)]
            start_idx = 0
            for size in sizes:
                chunks.append(media_queue[start_idx:start_idx + size])
                start_idx += size

    total_albums = len(chunks)
    for index, chunk in enumerate(chunks):
        input_media = []
        for i, item in enumerate(chunk):
            caption = album_caption if i == 0 else None
            MediaClass = InputMediaPhoto if item["type"] == "photo" else InputMediaVideo
            input_media.append(MediaClass(media=item["media"], caption=caption))
        
        for attempt in range(5):
            try:
                await context.bot.send_media_group(chat_id=target_chat_id, media=input_media)
                break
            except RetryAfter as e:
                logger.warning(f"RetryAfter on chunk {index+1}, waiting {e.retry_after}s")
                await asyncio.sleep(e.retry_after)
            except Exception as e:
                logger.error(f"Failed to send chunk {index+1}: {e}")
                break
        
        progress_msg_id = context.user_data.get("progress_message_id")
        if progress_msg_id and total_albums > 1:
            try:
                progress_text = f"{MESSAGES['processing_album_start']}\n"
                progress_text += MESSAGES['progress_update'].format(processed_albums=index + 1, total_albums=total_albums, time_remaining_str="...")
                await context.bot.edit_message_text(chat_id=user_chat_id, message_id=progress_msg_id, text=progress_text, parse_mode=ParseMode.MARKDOWN)
            except Exception as e:
                logger.warning(f"Failed to update progress message: {e}")
        
        if index < total_albums - 1:
            await asyncio.sleep(get_random_delay())

    context.user_data["media_queue"] = []

async def reset_album(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await initialize_user_data(context, update.effective_chat.id)
    context.user_data["media_queue"] = []
    context.user_data.pop("current_album_caption", None)
    await update.message.reply_text(MESSAGES["queue_cleared"], reply_markup=get_main_reply_markup())

async def cancel_operation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    chat_id = update.effective_chat.id
    if update.callback_query:
        await update.callback_query.answer()
        chat_id = update.callback_query.message.chat_id
        try: await update.callback_query.delete_message()
        except: pass
    
    await delete_messages_from_queue(context, chat_id)
    
    text, markup = (MESSAGES["cancel_operation"], get_main_reply_markup())
    await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=markup)
    
    context.user_data.pop("current_album_caption", None)
    
    return ConversationHandler.END

cancel_album_creation = cancel_operation
cancel_operation_general = cancel_operation

# ุชุดุบูู ุงูุจูุช
def main() -> None:
    token = os.getenv("BOT_TOKEN")
    if not token:
        logger.error("BOT_TOKEN not set in environment variables.")
        return
    
    application = Application.builder().token(token).build()

    # ุชู ุญุฐู ูุญุงุฏุซุฉ ุชุบููุฑ ูุฌูุฉ ุงูุฃูุจูู
    # dest_conv

    # ูุญุงุฏุซุฉ ูุชุบููุฑ ููุท ุงูุชูุณูู
    split_mode_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.TEXT & filters.Regex(f"^{re.escape(MESSAGES['keyboard_change_split_mode'])}$"), prompt_for_split_mode_setting)],
        states={CHANGING_SPLIT_MODE: [CallbackQueryHandler(handle_split_mode_choice, pattern=f"^{SPLIT_SET_CB_PREFIX}.*|^{CANCEL_CB_DATA}$")]},
        fallbacks=[CommandHandler("cancel", cancel_operation_general)]
    )

    # ูุญุงุฏุซุฉ ูุฅูุดุงุก ุงูุฃูุจูู
    album_creation_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.TEXT & filters.Regex(f"^{re.escape(MESSAGES['keyboard_done'])}$"), start_album_creation_process)],
        states={
            ASKING_FOR_CAPTION: [CallbackQueryHandler(handle_caption_choice, pattern=f"^{CAPTION_CB_PREFIX}.*|^{CANCEL_CB_DATA}$")],
            ASKING_FOR_MANUAL_CAPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_manual_album_caption)],
        },
        fallbacks=[CommandHandler("cancel", cancel_album_creation)]
    )

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    
    # ุฅุถุงูุฉ ุงููุนุงูุฌุงุช ุงููุชุจููุฉ
    application.add_handler(split_mode_conv)
    application.add_handler(album_creation_conv)
    
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex(f"^{re.escape(MESSAGES['keyboard_clear'])}$"), reset_album))
    application.add_handler(MessageHandler(filters.PHOTO & ~filters.COMMAND, add_photo))
    application.add_handler(MessageHandler(filters.VIDEO & ~filters.COMMAND, add_video))

    logger.info("Bot started polling...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == '__main__':
    main()
